import type { Prisma } from '@prisma/client';
import fetch from 'node-fetch';

import { env } from '../config/env.js';
import { parseEnvironmentMetadata } from './environmentMetadata.js';
import { prisma } from './prisma.js';

const sanitizeHost = (name: string) => name.toLowerCase().replace(/[^a-z0-9-]/g, '-');
const ensureDomain = (value: string) => value.replace(/^\./, '') || 'switchyard.localhost';
const SLOT_A_LABEL = 'slot-a';
const SLOT_B_LABEL = 'slot-b';

const resolveProxyTarget = (environment: {
  targetUrl: string;
  metadata: Prisma.JsonValue | null;
}) => {
  const meta = parseEnvironmentMetadata(environment.metadata);
  if (env.dockerNetwork && meta.containerName && meta.appPort) {
    return `http://${meta.containerName}:${meta.appPort}`;
  }
  if (!env.dockerNetwork && meta.hostPort) {
    return `${env.routerTargetHost}:${meta.hostPort}`;
  }
  return environment.targetUrl;
};

const buildHostBlock = (
  host: string,
  environment: { label: string; targetUrl: string; metadata: Prisma.JsonValue | null },
) => {
  const siteLabel = host.startsWith('http://') || host.startsWith('https://') ? host : `http://${host}`;
  const proxyTarget = resolveProxyTarget(environment);
  return `${siteLabel} {
  encode gzip
  reverse_proxy ${proxyTarget} {
    header_up X-Switchyard-Env ${environment.label}
  }
}
`;
};

const buildGlobalBlock = () => {
  let adminAddress = ':2019';
  if (env.caddyAdminUrl) {
    try {
      const parsed = new URL(env.caddyAdminUrl);
      adminAddress = parsed.port ? `:${parsed.port}` : adminAddress;
    } catch {
      // ignore parse errors and keep default
    }
  }
  return `{
  admin ${adminAddress}
  auto_https off
}
`;
};

export const buildCaddyfileContents = async () => {
  const services = await prisma.service.findMany({ include: { environments: true } });
  const blocks: string[] = [];
  const routerDomain = ensureDomain(env.routerDomain);
  const consoleSubdomain = env.consoleSubdomain ? sanitizeHost(env.consoleSubdomain.replace(/^https?:\/\//i, '')) : '';
  const consoleTarget = env.consoleTargetOrigin;

  const buildHostname = (serviceName: string, prefix?: string) => {
    const serviceSlug = sanitizeHost(serviceName);
    if (prefix) {
      return `${prefix}.${serviceSlug}.${routerDomain}`;
    }
    return `${serviceSlug}.${routerDomain}`;
  };

  for (const service of services) {
    const slotA = service.environments.find((env) => env.label === SLOT_A_LABEL);
    const slotB = service.environments.find((env) => env.label === SLOT_B_LABEL);
    const activeTargets = service.environments.filter((env) => env.isActive);
    const liveTarget = activeTargets[0] ?? slotB ?? slotA;
    const standbyTarget = service.environments.find((env) => !env.isActive) ?? (liveTarget?.id === slotA?.id ? slotB : slotA);

    if (slotA) {
      const slotAHost = buildHostname(service.name, SLOT_A_LABEL);
      blocks.push(buildHostBlock(slotAHost, slotA));
    }

    if (slotB) {
      const slotBHost = buildHostname(service.name, SLOT_B_LABEL);
      blocks.push(buildHostBlock(slotBHost, slotB));
    }

    if (liveTarget) {
      const liveHost = buildHostname(service.name);
      blocks.push(buildHostBlock(liveHost, liveTarget));
    }

    if (standbyTarget) {
      const stagingHost = buildHostname(service.name, 'staging');
      blocks.push(buildHostBlock(stagingHost, standbyTarget));
    }
  }

  if (consoleSubdomain && consoleTarget) {
    const consoleHost = `${consoleSubdomain}.${routerDomain}`;
    const consoleApiTarget = env.dockerNetwork ? 'http://backend:4201' : `${env.routerTargetHost}:4201`;
    const consoleBlock = `{
  encode gzip
  @api path /api/* /ws
  handle @api {
    reverse_proxy ${consoleApiTarget}
  }
  handle {
    reverse_proxy ${consoleTarget}
  }
}
`;
    blocks.push(`http://${consoleHost} ${consoleBlock}`);
    blocks.push(`https://${consoleHost} ${consoleBlock}`);
  }

  const globalBlock = buildGlobalBlock();

  return `# Auto generated by Switchyard on ${new Date().toISOString()}
${globalBlock}
:80 {
  respond "Switchyard Caddy router is running" 200
}

${blocks.join('\n')}
`;
};

export const regenerateCaddyfile = async () => {
  const contents = await buildCaddyfileContents();

  if (!env.caddyAdminUrl) {
    throw new Error('CADDY_ADMIN_URL must be set to load the router via API.');
  }

  const adminEndpoint = `${env.caddyAdminUrl.replace(/\/$/, '')}/load?adapter=caddyfile`;
  const response = await fetch(adminEndpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'text/caddyfile' },
    body: contents,
  });
  if (!response.ok) {
    throw new Error(`Caddy admin responded with ${response.status}`);
  }
  console.log(`[CADDY] Loaded router config via admin API (${adminEndpoint})`);
  return adminEndpoint;
};
